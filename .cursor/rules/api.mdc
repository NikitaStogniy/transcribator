---
description: React query rules
globs: *.ts
---
# React Query Usage Rules

## Overview

The project uses React Query for managing API calls and caching with a unified approach. This document outlines the rules and best practices for working with React Query in the project.

```
app/
├── api/                      // API routes
├── dashboard/                // App routes 
│   └── files/
│       └── page.tsx
├── components/               // Shared components
└── hooks/                    // React Query hooks
    ├── use-files.ts          // File-related queries
    ├── use-team.ts           // Team-related queries
    ├── use-transcriptions.ts // Transcription-related queries
    └── ...
```

## Организация Query Hooks

```typescript
// hooks/use-files.ts
export function useFiles() {
  const { data: selectedTeamId } = useSelectedTeam();

  return useQuery({
    queryKey: ["files", selectedTeamId],
    queryFn: () => fetchFiles(selectedTeamId),
    enabled: !!selectedTeamId,
  });
}

export function useFileUpload() {
  const queryClient = useQueryClient();
  const { data: selectedTeamId } = useSelectedTeam();

  return useMutation({
    mutationFn: uploadFile,
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["files", selectedTeamId] });
    },
  });
}
```

## API-функции

```typescript
// hooks/use-files.ts (продолжение)
const fetchFiles = async (teamId?: string): Promise<File[]> => {
  const url = teamId ? `/api/files?teamId=${teamId}` : "/api/files";
  const response = await fetch(url);

  if (!response.ok) {
    throw new Error("Failed to fetch files");
  }

  return response.json();
};

const uploadFile = async (fileData: FileUpload): Promise<File> => {
  const response = await fetch("/api/files", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
    },
    body: JSON.stringify(fileData),
  });

  if (!response.ok) {
    throw new Error("Failed to upload file");
  }

  return response.json();
};
```

## Query Keys

Для проекта мы используем простую структуру ключей:

```typescript
// Примеры ключей запросов
["files", teamId]               // Список файлов для команды
["file", fileId]                // Конкретный файл
["team", teamId]                // Данные команды
["transcriptions", teamId]      // Транскрипции для команды
["transcription", id]           // Конкретная транскрипция
["selectedTeam"]                // Выбранная команда
```

## Использование в компонентах

```tsx
// app/dashboard/files/page.tsx
'use client';

import { useFiles, useFilesByStatus, useFileUpload } from "@/hooks/use-files";

export default function FilesPage() {
  const { isLoading, error } = useFiles();
  const filesByStatus = useFilesByStatus();
  
  if (isLoading) return <div>Loading files...</div>;
  if (error) return <div>Error loading files: {(error as Error).message}</div>;
  
  return (
    <div>
      <h1>Files</h1>
      <p>Total files: {filesByStatus.all.length}</p>
      {/* ... */}
    </div>
  );
}
```

## Правила именования хуков

Следуйте паттерну: `use[Сущность]` или `use[Действие][Сущность]`

```typescript
// Получение данных
useFiles();
useTeam();
useTranscription(id);

// Изменение данных
useFileUpload();
useUpdateTranscription();
useAddTeamMember();
```

## Лучшие практики

1. Всегда обрабатывайте состояния загрузки и ошибки:

```typescript
const { data, isLoading, error } = useFiles();

if (isLoading) return <div>Loading...</div>;
if (error) return <div>Error: {(error as Error).message}</div>;
```

2. Используйте кэш для оптимизации запросов:

```typescript
const queryClient = useQueryClient();

// Обновление кэша после мутации
queryClient.invalidateQueries({ queryKey: ["files", selectedTeamId] });

// Прямое изменение кэша
queryClient.setQueryData(["transcription", data.id], data);
```
